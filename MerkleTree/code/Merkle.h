#ifndef MERKLE_H__
#define MERKLE_H__

#include <string>
#include <memory>
#include <vector>

using namespace std;

// Defines structure for node in the Merkle Tree
struct Node {
  shared_ptr<Node> parent; // Parent node

  shared_ptr<Node> left; // Left child node

  shared_ptr<Node> right; // Right child node

  string hashkey; // Hash string for current node, generated by the SHA-256 hashing algorithm
};




class MerkleTree {

  public:

    MerkleTree(); // Constructor; initializes class variables/pointers

    ~MerkleTree(); // Deconstructor


  // Node creation methods

      shared_ptr<Node> InitLeaf(string data); // Initialize a leaf node with the given data 

      shared_ptr<Node> InitTreeNode(shared_ptr<Node> left, shared_ptr<Node> right); // Create a tree node 


  // Methods for determining size/structure

      int GetSize(); // Return total number of nodes in the tree

        int GetSize(shared_ptr<Node> branchroot); // Return number of nodes in the specified branch of the tree--incl. the root of that branch

      int GetDepth(); // Return depth of tree

        int GetDepth(shared_ptr<Node> subroot); // Return depth of subtree starting from specified node



  // Methods to confirm the existence of data and their hashes

      bool ContainsData(string data); // Check if the data is encoded in the hash key of one of the tree's leaf nodes

        bool ContainsData(string data, shared_ptr<Node> subtree); // Recursive helper function for ContainsData

      bool ContainsHash(string hash); // Check if the tree contains a node storing the given hash key 

        bool ContainsHash(string hash, shared_ptr<Node> subtree); // Recursive helper function for ContainsHash



  // Methods to modify the tree (add/remove nodes)

      void InsertNode(shared_ptr<Node> newnode); // Insert a node into the tree, reducing asymmetry of its constituent branches

        bool InsertNode(shared_ptr<Node> newnode, shared_ptr<Node> target); // Insert a node at the specified position in the tree

      void DeleteLeaf(shared_ptr<Node> deletion); // Delete the specified leaf node



  // Methods to locate data/hashkeys within the tree

      shared_ptr<Node> FindData(string data); // Return a pointer to the leaf node containing a hash of the specified data, or nullptr if tree doesn't a hash of the data

        shared_ptr<Node> FindData(string data, shared_ptr<Node> subtree); // Return a ptr to the leaf node in the subtree containing a hash of the data, or null if no match exists

      shared_ptr<Node> FindHash(string hash); // Return a pointer to the node containing the specified hash key, or nullptr if the tree doesn't contain the key

        shared_ptr<Node> FindHash(string hash, shared_ptr<Node> subtree); // Return a ptr to the first node in the subtree whose hashkey matches the specified hash; return NULL if no match found



  // Methods for checking & restoring the integrity of a trees data

      bool Verify(MerkleTree copy); // Return false if the data in the tree copy has been altered, true otherwise

      void Resolve(shared_ptr<Node> mod); // Helper function for ModifyLeaf() & Confirm(); given a pointer to a modified leaf node, update the hash keys of that node's ancestors

      void ModifyLeaf(shared_ptr<Node> target, string newdata); // Change or replace the data hashed in a specified leaf node and update the hashkeys of its ancestors

      void AcceptMods(MerkleTree copy); // Confirm the changes in the copy tree by updating the hash keys of the current tree

      void AcceptMods(MerkleTree copy, shared_ptr<Node> sourceNode, shared_ptr<Node> copyNode); // Recursive helper for AcceptMods




  // Misc helper functions

      shared_ptr<Node> GetSibling(shared_ptr<Node> node); // Return pointer to the other child of the specified node's parent--or null, if node parameter is null or equal to the root pointer

      shared_ptr<Node> GetRoot(); // Return pointer to the root node in the Merkle Tree

      void SetRoot(shared_ptr<Node> newroot); // Set the root of the tree to the specified node

      bool IsRoot(shared_ptr<Node> node); // Returns true if the given node is the tree's root node

      string GetPosition(shared_ptr<Node> node); // Returns "left, "right," or "none", depending on which child of its parent the given node is 

      bool IsLeaf(shared_ptr<Node> node); // Returns true if node is a leaf & false otherwise

      shared_ptr<Node> CopyBranch(shared_ptr<Node> branch); // Creates a copy of the specified branch & returns a pointer to that copy

  private:

    shared_ptr<Node> root_ptr; // Pointer to the root node in the Merkle Tree

};

#endif // MERKLE_H__